"""
Exception Flow Analysis for PySpectre.
This module analyzes exception handling patterns including:
- Uncaught exceptions
- Too broad exception handlers
- Exception swallowing (catch and ignore)
- Re-raise patterns
- Exception chain analysis
- Finally block analysis
"""

from __future__ import annotations

import ast
import dis
from collections import defaultdict
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import (
    Any,
)


class ExceptionWarningKind(Enum):
    """Types of exception warnings."""

    UNCAUGHT_EXCEPTION = auto()
    TOO_BROAD_EXCEPT = auto()
    BARE_EXCEPT = auto()
    EXCEPTION_SWALLOWED = auto()
    EXCEPTION_NOT_LOGGED = auto()
    RERAISE_DIFFERENT_TYPE = auto()
    EMPTY_EXCEPT_BLOCK = auto()
    FINALLY_RETURN = auto()
    EXCEPTION_IN_FINALLY = auto()
    UNREACHABLE_EXCEPT = auto()
    DUPLICATE_EXCEPT = auto()
    WRONG_EXCEPTION_ORDER = auto()


@dataclass
class ExceptionWarning:
    """Warning about exception handling."""

    kind: ExceptionWarningKind
    file: str
    line: int
    message: str
    exception_type: str | None = None
    severity: str = "warning"


@dataclass
class ExceptionHandler:
    """Represents an exception handler."""

    line: int
    exception_types: list[str]
    is_bare: bool = False
    is_empty: bool = False
    has_reraise: bool = False
    has_pass: bool = False
    has_logging: bool = False


@dataclass
class TryBlock:
    """Represents a try-except-finally block."""

    start_line: int
    end_line: int
    handlers: list[ExceptionHandler] = field(default_factory=list)
    has_finally: bool = False
    has_else: bool = False
    raises_in_try: list[str] = field(default_factory=list)
    raises_in_finally: bool = False
    returns_in_finally: bool = False


class ExceptionASTAnalyzer(ast.NodeVisitor):
    """
    AST-based exception analysis.
    """

    def __init__(self, file_path: str) -> None:
        self.file_path = file_path
        self.warnings: list[ExceptionWarning] = []
        self.try_blocks: list[TryBlock] = []
        self.current_function: str | None = None
        self.function_raises: dict[str, set[str]] = defaultdict(set)

    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:
        """Visit function definition."""
        old_function = self.current_function
        self.current_function = node.name
        self.generic_visit(node)
        self.current_function = old_function

    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> None:
        """Visit async function definition."""
        old_function = self.current_function
        self.current_function = node.name
        self.generic_visit(node)
        self.current_function = old_function

    def visit_Try(self, node: ast.Try) -> None:
        """Analyze try-except-finally block."""
        try_block = TryBlock(
            start_line=node.lineno,
            end_line=node.end_lineno or node.lineno,
            has_finally=bool(node.finalbody),
            has_else=bool(node.orelse),
        )
        for child in ast.walk(node):
            if isinstance(child, ast.Raise):
                if child.exc:
                    if isinstance(child.exc, ast.Call):
                        if isinstance(child.exc.func, ast.Name):
                            try_block.raises_in_try.append(child.exc.func.id)
                    elif isinstance(child.exc, ast.Name):
                        try_block.raises_in_try.append(child.exc.id)
        caught_types: list[str] = []
        for handler in node.handlers:
            exc_handler = self._analyze_handler(handler)
            try_block.handlers.append(exc_handler)
            caught_types.extend(exc_handler.exception_types)
        self._check_handler_issues(node.handlers, caught_types)
        if node.finalbody:
            for stmt in node.finalbody:
                if isinstance(stmt, ast.Return):
                    try_block.returns_in_finally = True
                    self.warnings.append(
                        ExceptionWarning(
                            kind=ExceptionWarningKind.FINALLY_RETURN,
                            file=self.file_path,
                            line=stmt.lineno,
                            message="Return in finally block can silence exceptions",
                            severity="error",
                        )
                    )
                for child in ast.walk(stmt):
                    if isinstance(child, ast.Raise):
                        try_block.raises_in_finally = True
                        self.warnings.append(
                            ExceptionWarning(
                                kind=ExceptionWarningKind.EXCEPTION_IN_FINALLY,
                                file=self.file_path,
                                line=child.lineno,
                                message="Raise in finally block can replace original exception",
                                severity="warning",
                            )
                        )
        self.try_blocks.append(try_block)
        self.generic_visit(node)

    def _analyze_handler(self, handler: ast.ExceptHandler) -> ExceptionHandler:
        """Analyze a single exception handler."""
        exc_handler = ExceptionHandler(line=handler.lineno, exception_types=[])
        if handler.type is None:
            exc_handler.is_bare = True
            exc_handler.exception_types = ["BaseException"]
            self.warnings.append(
                ExceptionWarning(
                    kind=ExceptionWarningKind.BARE_EXCEPT,
                    file=self.file_path,
                    line=handler.lineno,
                    message="Bare 'except:' catches all exceptions including SystemExit and KeyboardInterrupt",
                    severity="warning",
                )
            )
        elif isinstance(handler.type, ast.Tuple):
            for elt in handler.type.elts:
                if isinstance(elt, ast.Name):
                    exc_handler.exception_types.append(elt.id)
        elif isinstance(handler.type, ast.Name):
            exc_handler.exception_types.append(handler.type.id)
            if handler.type.id == "Exception":
                self.warnings.append(
                    ExceptionWarning(
                        kind=ExceptionWarningKind.TOO_BROAD_EXCEPT,
                        file=self.file_path,
                        line=handler.lineno,
                        message="Catching 'Exception' is too broad, consider catching specific exceptions",
                        severity="warning",
                    )
                )
            elif handler.type.id == "BaseException":
                self.warnings.append(
                    ExceptionWarning(
                        kind=ExceptionWarningKind.TOO_BROAD_EXCEPT,
                        file=self.file_path,
                        line=handler.lineno,
                        message="Catching 'BaseException' catches all exceptions including SystemExit",
                        severity="error",
                    )
                )
        if not handler.body:
            exc_handler.is_empty = True
        elif len(handler.body) == 1:
            stmt = handler.body[0]
            if isinstance(stmt, ast.Pass):
                exc_handler.has_pass = True
                exc_handler.is_empty = True
                self.warnings.append(
                    ExceptionWarning(
                        kind=ExceptionWarningKind.EXCEPTION_SWALLOWED,
                        file=self.file_path,
                        line=handler.lineno,
                        message="Exception silently ignored with 'pass'",
                        severity="warning",
                    )
                )
            elif isinstance(stmt, ast.Expr) and isinstance(stmt.value, ast.Constant):
                exc_handler.is_empty = True
        for stmt in ast.walk(handler):
            if isinstance(stmt, ast.Raise):
                exc_handler.has_reraise = True
                break
        for stmt in ast.walk(handler):
            if isinstance(stmt, ast.Call):
                if isinstance(stmt.func, ast.Attribute):
                    if stmt.func.attr in {
                        "error",
                        "exception",
                        "warning",
                        "critical",
                        "debug",
                        "info",
                    }:
                        exc_handler.has_logging = True
                        break
                elif isinstance(stmt.func, ast.Name):
                    if stmt.func.id in {"print", "logging"}:
                        exc_handler.has_logging = True
                        break
        if exc_handler.is_empty and not exc_handler.has_logging:
            self.warnings.append(
                ExceptionWarning(
                    kind=ExceptionWarningKind.EXCEPTION_NOT_LOGGED,
                    file=self.file_path,
                    line=handler.lineno,
                    message="Exception caught but not logged or handled",
                    severity="warning",
                )
            )
        return exc_handler

    def _check_handler_issues(
        self,
        handlers: list[ast.ExceptHandler],
        caught_types: list[str],
    ) -> None:
        """Check for handler ordering and duplication issues."""
        seen_types: set[str] = set()
        EXCEPTION_HIERARCHY = {
            "Exception": {
                "ValueError",
                "TypeError",
                "KeyError",
                "IndexError",
                "AttributeError",
                "RuntimeError",
                "IOError",
                "OSError",
            },
            "LookupError": {"KeyError", "IndexError"},
            "ArithmeticError": {"ZeroDivisionError", "OverflowError"},
            "OSError": {"FileNotFoundError", "PermissionError", "ConnectionError"},
        }
        broad_handlers_seen: set[str] = set()
        for handler in handlers:
            if handler.type is None:
                continue
            if isinstance(handler.type, ast.Name):
                exc_type = handler.type.id
                if exc_type in seen_types:
                    self.warnings.append(
                        ExceptionWarning(
                            kind=ExceptionWarningKind.DUPLICATE_EXCEPT,
                            file=self.file_path,
                            line=handler.lineno,
                            message=f"Duplicate handler for '{exc_type}'",
                            exception_type=exc_type,
                        )
                    )
                for broad, specific_set in EXCEPTION_HIERARCHY.items():
                    if broad in broad_handlers_seen and exc_type in specific_set:
                        self.warnings.append(
                            ExceptionWarning(
                                kind=ExceptionWarningKind.UNREACHABLE_EXCEPT,
                                file=self.file_path,
                                line=handler.lineno,
                                message=f"Handler for '{exc_type}' unreachable after '{broad}'",
                                exception_type=exc_type,
                            )
                        )
                seen_types.add(exc_type)
                if exc_type in EXCEPTION_HIERARCHY:
                    broad_handlers_seen.add(exc_type)

    def visit_Raise(self, node: ast.Raise) -> None:
        """Track raised exceptions."""
        if self.current_function and node.exc:
            if isinstance(node.exc, ast.Call):
                if isinstance(node.exc.func, ast.Name):
                    self.function_raises[self.current_function].add(node.exc.func.id)
            elif isinstance(node.exc, ast.Name):
                self.function_raises[self.current_function].add(node.exc.id)
        self.generic_visit(node)

    def analyze(self, source: str) -> list[ExceptionWarning]:
        """Analyze source code for exception issues."""
        try:
            tree = ast.parse(source)
            self.visit(tree)
        except SyntaxError:
            pass
        return self.warnings


class ExceptionBytecodeAnalyzer:
    """
    Bytecode-based exception flow analysis.
    """

    def analyze(
        self,
        code: Any,
        file_path: str = "<unknown>",
    ) -> list[ExceptionWarning]:
        """Analyze bytecode for exception patterns."""
        warnings: list[ExceptionWarning] = []
        instructions = list(dis.get_instructions(code))
        current_line = code.co_firstlineno
        in_except = False
        except_start_line = 0
        has_meaningful_handler = False
        for i, instr in enumerate(instructions):
            if instr.starts_line:
                current_line = instr.starts_line
            opname = instr.opname
            if opname == "PUSH_EXC_INFO":
                in_except = True
                except_start_line = current_line
                has_meaningful_handler = False
            elif opname == "POP_EXCEPT":
                if in_except and not has_meaningful_handler:
                    pass
                in_except = False
            elif in_except:
                if opname in {
                    "CALL",
                    "CALL_FUNCTION",
                    "CALL_METHOD",
                    "STORE_FAST",
                    "STORE_NAME",
                    "RAISE_VARARGS",
                }:
                    has_meaningful_handler = True
            if opname == "RERAISE":
                pass
            elif opname == "RAISE_VARARGS" and in_except:
                if instr.arg == 1:
                    pass
        return warnings


class UncaughtExceptionAnalyzer:
    """
    Analyzes which exceptions might propagate out of functions.
    """

    OPERATION_EXCEPTIONS: dict[str, list[str]] = {
        "BINARY_SUBSCR": ["KeyError", "IndexError", "TypeError"],
        "BINARY_TRUE_DIVIDE": ["ZeroDivisionError"],
        "BINARY_FLOOR_DIVIDE": ["ZeroDivisionError"],
        "BINARY_MODULO": ["ZeroDivisionError"],
        "STORE_SUBSCR": ["KeyError", "IndexError", "TypeError"],
        "DELETE_SUBSCR": ["KeyError", "IndexError", "TypeError"],
        "LOAD_ATTR": ["AttributeError"],
        "STORE_ATTR": ["AttributeError"],
        "DELETE_ATTR": ["AttributeError"],
        "IMPORT_NAME": ["ImportError", "ModuleNotFoundError"],
        "IMPORT_FROM": ["ImportError"],
    }

    def analyze(
        self,
        code: Any,
        file_path: str = "<unknown>",
    ) -> dict[str, set[str]]:
        """
        Analyze what exceptions might be raised by a function.
        Returns mapping of operation -> potential exceptions.
        """
        potential_exceptions: dict[str, set[str]] = defaultdict(set)
        instructions = list(dis.get_instructions(code))
        current_line = code.co_firstlineno
        protected_ranges: list[tuple[int, int, set[str]]] = []
        for instr in instructions:
            if instr.starts_line:
                current_line = instr.starts_line
            opname = instr.opname
            if opname in self.OPERATION_EXCEPTIONS:
                exc_types = self.OPERATION_EXCEPTIONS[opname]
                is_protected = False
                for start, end, caught in protected_ranges:
                    if start <= instr.offset <= end:
                        for exc in exc_types:
                            if exc in caught or "Exception" in caught or "BaseException" in caught:
                                is_protected = True
                                break
                if not is_protected:
                    for exc in exc_types:
                        potential_exceptions[str(current_line)].add(exc)
            if opname == "RAISE_VARARGS":
                pass
        return dict(potential_exceptions)


class ExceptionChainAnalyzer:
    """
    Analyzes exception chaining patterns (raise from).
    """

    def analyze_source(
        self,
        source: str,
        file_path: str = "<unknown>",
    ) -> list[ExceptionWarning]:
        """Analyze exception chaining in source."""
        warnings: list[ExceptionWarning] = []
        try:
            tree = ast.parse(source)
        except SyntaxError:
            return warnings

        class ChainVisitor(ast.NodeVisitor):
            def visit_Raise(self, node: ast.Raise) -> None:
                if node.exc and not node.cause:
                    pass
                self.generic_visit(node)

        visitor = ChainVisitor()
        visitor.visit(tree)
        return warnings


class ExceptionAnalyzer:
    """
    High-level interface for exception analysis.
    """

    def __init__(self) -> None:
        self.bytecode_analyzer = ExceptionBytecodeAnalyzer()
        self.uncaught_analyzer = UncaughtExceptionAnalyzer()
        self.chain_analyzer = ExceptionChainAnalyzer()

    def analyze_source(
        self,
        source: str,
        file_path: str = "<unknown>",
    ) -> list[ExceptionWarning]:
        """Analyze source for exception issues."""
        ast_analyzer = ExceptionASTAnalyzer(file_path)
        warnings = ast_analyzer.analyze(source)
        warnings.extend(self.chain_analyzer.analyze_source(source, file_path))
        return warnings

    def analyze_function(
        self,
        code: Any,
        file_path: str = "<unknown>",
    ) -> list[ExceptionWarning]:
        """Analyze function bytecode for exception issues."""
        return self.bytecode_analyzer.analyze(code, file_path)

    def analyze_file(self, file_path: str) -> list[ExceptionWarning]:
        """Analyze file for exception issues."""
        try:
            with open(file_path, encoding="utf-8", errors="ignore") as f:
                source = f.read()
            warnings = self.analyze_source(source, file_path)
            code = compile(source, file_path, "exec")
            warnings.extend(self.analyze_function(code, file_path))
            self._analyze_nested(code, file_path, warnings)
            return warnings
        except SyntaxError as e:
            return [
                ExceptionWarning(
                    kind=ExceptionWarningKind.UNCAUGHT_EXCEPTION,
                    file=file_path,
                    line=e.lineno or 0,
                    message=f"Syntax error: {e.msg}",
                )
            ]
        except Exception:
            return []

    def _analyze_nested(
        self,
        code: Any,
        file_path: str,
        warnings: list[ExceptionWarning],
    ) -> None:
        """Analyze nested functions."""
        for const in code.co_consts:
            if hasattr(const, "co_code"):
                warnings.extend(self.analyze_function(const, file_path))
                self._analyze_nested(const, file_path, warnings)

    def get_potential_exceptions(
        self,
        code: Any,
    ) -> dict[str, set[str]]:
        """Get potential uncaught exceptions by line."""
        return self.uncaught_analyzer.analyze(code)

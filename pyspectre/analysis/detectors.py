"""Bug detectors for symbolic execution.
PySpectre v1.1 - Enhanced detectors included:
- Improved index/key error detection
- Null/None dereference detection
- Enhanced type confusion detection
- Format string vulnerability detection
- Resource leak detection
- Enhanced integer overflow detection
"""

from __future__ import annotations

import dis
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import TYPE_CHECKING, Any

import z3

if TYPE_CHECKING:
    from pyspectre.core.state import VMState


class IssueKind(Enum):
    """Types of issues that can be detected."""

    DIVISION_BY_ZERO = auto()
    ASSERTION_ERROR = auto()
    INDEX_ERROR = auto()
    KEY_ERROR = auto()
    TYPE_ERROR = auto()
    ATTRIBUTE_ERROR = auto()
    OVERFLOW = auto()
    NULL_DEREFERENCE = auto()
    INFINITE_LOOP = auto()
    UNREACHABLE_CODE = auto()
    UNHANDLED_EXCEPTION = auto()
    RECURSION_LIMIT = auto()
    NEGATIVE_SQRT = auto()
    INVALID_ARGUMENT = auto()
    FORMAT_STRING_INJECTION = auto()
    RESOURCE_LEAK = auto()


@dataclass
class Issue:
    """Represents a detected issue."""

    kind: IssueKind
    message: str
    constraints: list[z3.ExprRef] = field(default_factory=list)
    model: z3.ModelRef | None = None
    pc: int = 0
    line_number: int | None = None
    function_name: str | None = None
    filename: str | None = None
    stack_trace: list[str] = field(default_factory=list)

    def get_counterexample(self) -> dict[str, Any]:
        """Extract counterexample from model."""
        if self.model is None:
            return {}
        counterexample = {}
        for decl in self.model.decls():
            name = decl.name()
            value = self.model[decl]
            base_name = name
            for suffix in ["_is_int", "_is_bool", "_is_none", "_is_str", "_int", "_bool", "_str"]:
                if name.endswith(suffix):
                    base_name = name[: -len(suffix)]
                    break
            if "_is_" in name or base_name.startswith("_"):
                continue
            try:
                if z3.is_int_value(value):
                    counterexample[base_name] = value.as_long()
                elif z3.is_true(value):
                    counterexample[base_name] = True
                elif z3.is_false(value):
                    counterexample[base_name] = False
                elif z3.is_string_value(value):
                    counterexample[base_name] = value.as_string()
                else:
                    counterexample[base_name] = str(value)
            except Exception:
                counterexample[base_name] = str(value)
        return counterexample

    def format(self) -> str:
        """Format issue for display."""
        lines = [f"[{self.kind.name}] {self.message}"]
        if self.filename or self.line_number or self.function_name:
            location = []
            if self.filename:
                location.append(self.filename)
            if self.function_name:
                location.append(f"in {self.function_name}()")
            if self.line_number:
                location.append(f"line {self.line_number}")
            lines.append(f"  Location: {', '.join(location)}")
        if self.pc:
            lines.append(f"  PC: {self.pc}")
        counterexample = self.get_counterexample()
        if counterexample:
            lines.append("  Counterexample:")
            for name, value in sorted(counterexample.items()):
                lines.append(f"    {name} = {value}")
        if self.stack_trace:
            lines.append("  Stack trace:")
            for frame in self.stack_trace:
                lines.append(f"    {frame}")
        return "\n".join(lines)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "kind": self.kind.name,
            "message": self.message,
            "pc": self.pc,
            "line_number": self.line_number,
            "function_name": self.function_name,
            "filename": self.filename,
            "counterexample": self.get_counterexample(),
            "stack_trace": self.stack_trace,
        }


class Detector(ABC):
    """Base class for bug detectors."""

    name: str = "base"
    description: str = "Base detector"
    issue_kind: IssueKind = IssueKind.UNHANDLED_EXCEPTION

    @abstractmethod
    def check(
        self,
        state: VMState,
        instruction: dis.Instruction,
        solver_check: callable,
    ) -> Issue | None:
        """
        Check for issues at the current state.
        Args:
            state: Current VM state
            instruction: Current instruction being executed
            solver_check: Function to check constraint satisfiability
        Returns:
            Issue if a problem is detected, None otherwise
        """


class DivisionByZeroDetector(Detector):
    """Detects potential division by zero errors."""

    name = "division-by-zero"
    description = "Detects division by zero"
    issue_kind = IssueKind.DIVISION_BY_ZERO
    DIVISION_OPS = {"BINARY_TRUE_DIVIDE", "BINARY_FLOOR_DIVIDE", "BINARY_MODULO"}

    def check(
        self,
        state: VMState,
        instruction: dis.Instruction,
        solver_check: callable,
    ) -> Issue | None:
        from pyspectre.core.solver import get_model, is_satisfiable
        from pyspectre.core.types import SymbolicValue

        if instruction.opname == "BINARY_OP":
            op_name = instruction.argrepr
            if "/" not in op_name and "%" not in op_name:
                return None
        elif instruction.opname not in self.DIVISION_OPS:
            return None
        if len(state.stack) < 2:
            return None
        divisor = state.stack[-1]
        if not isinstance(divisor, SymbolicValue):
            try:
                if float(divisor) == 0:
                    return Issue(
                        kind=IssueKind.DIVISION_BY_ZERO,
                        message="Division by concrete zero",
                        pc=state.pc,
                    )
            except (ValueError, TypeError):
                pass
            return None
        zero_constraint = [
            *state.path_constraints,
            divisor.is_int,
            divisor.z3_int == 0,
        ]
        if is_satisfiable(zero_constraint):
            return Issue(
                kind=IssueKind.DIVISION_BY_ZERO,
                message=f"Possible division by zero: {divisor.name} can be 0",
                constraints=zero_constraint,
                model=get_model(zero_constraint),
                pc=state.pc,
            )
        return None


class AssertionErrorDetector(Detector):
    """Detects failing assertions."""

    name = "assertion-error"
    description = "Detects failing assertions"
    issue_kind = IssueKind.ASSERTION_ERROR

    def check(
        self,
        state: VMState,
        instruction: dis.Instruction,
        solver_check: callable,
    ) -> Issue | None:
        from pyspectre.core.solver import get_model

        if instruction.opname != "RAISE_VARARGS":
            return None
        return Issue(
            kind=IssueKind.ASSERTION_ERROR,
            message="Possible assertion failure",
            constraints=list(state.path_constraints),
            model=get_model(list(state.path_constraints)),
            pc=state.pc,
        )


class IndexErrorDetector(Detector):
    """Detects out-of-bounds array/list access."""

    name = "index-error"
    description = "Detects out-of-bounds indexing"
    issue_kind = IssueKind.INDEX_ERROR

    def check(
        self,
        state: VMState,
        instruction: dis.Instruction,
        solver_check: callable,
    ) -> Issue | None:
        from pyspectre.core.solver import get_model, is_satisfiable
        from pyspectre.core.types import SymbolicList, SymbolicValue

        if instruction.opname != "BINARY_SUBSCR":
            return None
        if len(state.stack) < 2:
            return None
        index = state.stack[-1]
        container = state.stack[-2]
        if not isinstance(container, SymbolicList):
            return None
        if not isinstance(index, SymbolicValue):
            return None
        oob_constraint = [
            *state.path_constraints,
            index.is_int,
            z3.Or(
                index.z3_int < 0,
                index.z3_int >= container.z3_len,
            ),
        ]
        if is_satisfiable(oob_constraint):
            return Issue(
                kind=IssueKind.INDEX_ERROR,
                message=f"Possible index out of bounds: {container.name}[{index.name}]",
                constraints=oob_constraint,
                model=get_model(oob_constraint),
                pc=state.pc,
            )
        return None


class KeyErrorDetector(Detector):
    """Detects missing dictionary keys."""

    name = "key-error"
    description = "Detects missing dictionary keys"
    issue_kind = IssueKind.KEY_ERROR

    def check(
        self,
        state: VMState,
        instruction: dis.Instruction,
        solver_check: callable,
    ) -> Issue | None:
        return None


class TypeErrorDetector(Detector):
    """Detects type errors in operations."""

    name = "type-error"
    description = "Detects type mismatches"
    issue_kind = IssueKind.TYPE_ERROR

    def check(
        self,
        state: VMState,
        instruction: dis.Instruction,
        solver_check: callable,
    ) -> Issue | None:
        from pyspectre.core.solver import get_model, is_satisfiable
        from pyspectre.core.types import SymbolicString, SymbolicValue

        if instruction.opname == "BINARY_OP":
            if len(state.stack) < 2:
                return None
            op = instruction.argrepr
            left = state.stack[-2]
            right = state.stack[-1]
            if op == "+":
                if isinstance(left, SymbolicString) and isinstance(right, SymbolicValue):
                    type_error = [
                        *state.path_constraints,
                        right.is_int,
                    ]
                    if is_satisfiable(type_error):
                        return Issue(
                            kind=IssueKind.TYPE_ERROR,
                            message=f"Cannot {op} string and int",
                            constraints=type_error,
                            model=get_model(type_error),
                            pc=state.pc,
                        )
        return None


class AttributeErrorDetector(Detector):
    """Detects attribute access errors."""

    name = "attribute-error"
    description = "Detects missing attributes"
    issue_kind = IssueKind.ATTRIBUTE_ERROR

    def check(
        self,
        state: VMState,
        instruction: dis.Instruction,
        solver_check: callable,
    ) -> Issue | None:
        return None


class OverflowDetector(Detector):
    """Detects integer overflow conditions."""

    name = "overflow"
    description = "Detects integer overflow"
    issue_kind = IssueKind.OVERFLOW
    BOUNDS = {
        "32bit": (-(2**31), 2**31 - 1),
        "64bit": (-(2**63), 2**63 - 1),
        "size_t": (0, 2**64 - 1),
    }

    def __init__(self, bound_type: str = "64bit"):
        self.min_val, self.max_val = self.BOUNDS.get(bound_type, self.BOUNDS["64bit"])

    def check(
        self,
        state: VMState,
        instruction: dis.Instruction,
        solver_check: callable,
    ) -> Issue | None:
        from pyspectre.core.solver import get_model, is_satisfiable
        from pyspectre.core.types import SymbolicValue

        if instruction.opname != "BINARY_OP":
            return None
        op = instruction.argrepr
        if op not in {"*", "+", "-", "**", "<<"}:
            return None
        if len(state.stack) < 2:
            return None
        left = state.stack[-2]
        right = state.stack[-1]
        if not isinstance(left, SymbolicValue) or not isinstance(right, SymbolicValue):
            return None
        if op == "*":
            result = left.z3_int * right.z3_int
        elif op == "+":
            result = left.z3_int + right.z3_int
        elif op == "-":
            result = left.z3_int - right.z3_int
        elif op == "<<":
            shift_overflow = [
                *state.path_constraints,
                left.is_int,
                right.is_int,
                right.z3_int > 63,
            ]
            if is_satisfiable(shift_overflow):
                return Issue(
                    kind=IssueKind.OVERFLOW,
                    message=f"Excessive bit shift: {right.name} could be > 63",
                    constraints=shift_overflow,
                    model=get_model(shift_overflow),
                    pc=state.pc,
                )
            return None
        elif op == "**":
            power_overflow = [
                *state.path_constraints,
                left.is_int,
                right.is_int,
                left.z3_int > 2,
                right.z3_int > 62,
            ]
            if is_satisfiable(power_overflow):
                return Issue(
                    kind=IssueKind.OVERFLOW,
                    message="Potential overflow in exponentiation",
                    constraints=power_overflow,
                    model=get_model(power_overflow),
                    pc=state.pc,
                )
            return None
        else:
            return None
        overflow_constraint = [
            *state.path_constraints,
            left.is_int,
            right.is_int,
            z3.Or(
                result > self.max_val,
                result < self.min_val,
            ),
        ]
        if is_satisfiable(overflow_constraint):
            return Issue(
                kind=IssueKind.OVERFLOW,
                message=f"Possible integer overflow in {op} operation",
                constraints=overflow_constraint,
                model=get_model(overflow_constraint),
                pc=state.pc,
            )
        return None


class EnhancedIndexErrorDetector(Detector):
    """
    Enhanced detector for out-of-bounds array/list access.
    Improvements over base:
    - Works with symbolic integer indexes
    - Tracks list length constraints
    - Handles negative indexing properly
    - Detects when index could exceed any reasonable bound
    - Skips likely dict access patterns to reduce false positives
    """

    name = "enhanced-index-error"
    description = "Enhanced out-of-bounds index detection"
    issue_kind = IssueKind.INDEX_ERROR
    MAX_REASONABLE_SIZE = 10000
    DICT_KEY_SUFFIXES = {
        "_id",
        "id",
        "key",
        "name",
        "feature",
        "tier",
        "type",
        "kind",
        "code",
        "mode",
        "command",
    }
    DICT_CONTAINER_PATTERNS = {
        "dict",
        "map",
        "cache",
        "tracker",
        "store",
        "registry",
        "config",
        "settings",
        "_recent",
        "_usage",
        "_count",
        "_limits",
        "_LIMITS",
        "_SIZE",
        "_join",
        "_command",
        "_confusion",
        "_requests",
    }
    SKIP_INDEX_PATTERNS = (
        "depth",
        "level",
        "count",
        "i",
        "j",
        "k",
        "n",
        "idx",
        "pos",
        "offset",
        "size",
        "length",
        "width",
        "height",
        "x",
        "y",
        "z",
    )
    INSTANCE_CONTAINER_PATTERNS = (
        "self.",
        "cls.",
        ".stack",
        ".elements",
        ".items",
        ".values",
        ".keys",
        ".methods",
        ".fields",
        ".attributes",
        ".properties",
        "._hooks",
        "._pending",
        "._alias",
        "._references",
        ".locals",
        ".globals",
        ".block_stack",
        "frame_copy",
        "closure_parent",
        "states",
    )

    def check(
        self,
        state: VMState,
        instruction: dis.Instruction,
        solver_check: callable,
    ) -> Issue | None:
        from pyspectre.core.types import SymbolicList, SymbolicValue

        if instruction.opname != "BINARY_SUBSCR":
            return None
        if len(state.stack) < 2:
            return None
        index = state.stack[-1]
        container = state.stack[-2]
        if isinstance(container, SymbolicList):
            return self._check_symbolic_list(state, container, index)
        if isinstance(index, SymbolicValue):
            if self._is_likely_dict_access(container, index):
                return None
            return self._check_unbounded_index(state, index)
        return None

    def _is_likely_dict_access(self, container, index) -> bool:
        """Check if this subscript is likely dict[key] rather than list[index]."""
        container_name = getattr(container, "name", "") or ""
        index_name = getattr(index, "name", "") or ""
        container_looks_like_dict = any(
            pattern in container_name.lower() for pattern in self.DICT_CONTAINER_PATTERNS
        )
        index_looks_like_key = any(
            index_name.lower().endswith(suffix) or suffix in index_name.lower()
            for suffix in self.DICT_KEY_SUFFIXES
        )
        container_is_instance_attr = any(
            pattern in container_name for pattern in self.INSTANCE_CONTAINER_PATTERNS
        )
        index_is_common_var = any(
            index_name == pattern or index_name.endswith(f"_{pattern}")
            for pattern in self.SKIP_INDEX_PATTERNS
        )
        return (
            container_looks_like_dict
            or index_looks_like_key
            or container_is_instance_attr
            or index_is_common_var
        )

    def _check_symbolic_list(self, state, container, index):
        from pyspectre.core.solver import get_model, is_satisfiable
        from pyspectre.core.types import SymbolicValue

        if not isinstance(index, SymbolicValue):
            try:
                idx_val = int(index)
                oob_constraint = [
                    *state.path_constraints,
                    z3.Or(
                        z3.IntVal(idx_val) >= container.z3_len,
                        z3.IntVal(idx_val) < -container.z3_len,
                    ),
                ]
                if is_satisfiable(oob_constraint):
                    return Issue(
                        kind=IssueKind.INDEX_ERROR,
                        message=f"Index {idx_val} may be out of bounds for {container.name}",
                        constraints=oob_constraint,
                        model=get_model(oob_constraint),
                        pc=state.pc,
                    )
            except (ValueError, TypeError):
                pass
            return None
        oob_constraint = [
            *state.path_constraints,
            index.is_int,
            z3.Or(
                index.z3_int >= container.z3_len,
                index.z3_int < -container.z3_len,
            ),
        ]
        if is_satisfiable(oob_constraint):
            return Issue(
                kind=IssueKind.INDEX_ERROR,
                message=f"Index {index.name} may be out of bounds for {container.name}",
                constraints=oob_constraint,
                model=get_model(oob_constraint),
                pc=state.pc,
            )
        return None

    def _check_unbounded_index(self, state, index):
        from pyspectre.core.solver import get_model, is_satisfiable

        large_constraint = [
            *state.path_constraints,
            index.is_int,
            index.z3_int >= self.MAX_REASONABLE_SIZE,
        ]
        if is_satisfiable(large_constraint):
            return Issue(
                kind=IssueKind.INDEX_ERROR,
                message=f"Index {index.name} could be unreasonably large (>= {self.MAX_REASONABLE_SIZE})",
                constraints=large_constraint,
                model=get_model(large_constraint),
                pc=state.pc,
            )
        return None


class NoneDereferenceDetector(Detector):
    """
    Detects attribute access or method calls on potentially None values.
    NOTE: This detector may produce false positives for class instance
    attributes accessed via 'self', as symbolic execution doesn't fully
    model Python's object initialization guarantees.
    """

    name = "none-dereference"
    description = "Detects attribute access on potentially None values"
    issue_kind = IssueKind.NULL_DEREFERENCE
    SKIP_NAMES = {"self", "cls", "module", "builtins", "__builtins__"}

    def check(
        self,
        state: VMState,
        instruction: dis.Instruction,
        solver_check: callable,
    ) -> Issue | None:
        from pyspectre.core.solver import get_model, is_satisfiable
        from pyspectre.core.types import SymbolicValue

        try:
            from pyspectre.core.types import SymbolicNone

            has_symbolic_none = True
        except ImportError:
            has_symbolic_none = False
        if instruction.opname not in ("LOAD_ATTR", "LOAD_METHOD", "STORE_ATTR"):
            return None
        if len(state.stack) < 1:
            return None
        obj = state.stack[-1]
        attr_name = instruction.argval
        if isinstance(obj, SymbolicValue):
            if obj.name in self.SKIP_NAMES:
                return None
        if has_symbolic_none:
            from pyspectre.core.types import SymbolicNone

            if isinstance(obj, SymbolicNone):
                return Issue(
                    kind=IssueKind.NULL_DEREFERENCE,
                    message=f"Attribute access '{attr_name}' on None",
                    constraints=list(state.path_constraints),
                    pc=state.pc,
                )
        if isinstance(obj, SymbolicValue):
            if obj.name in self.SKIP_NAMES:
                return None
            if hasattr(obj, "is_none"):
                none_constraint = [
                    *state.path_constraints,
                    obj.is_none,
                ]
                if is_satisfiable(none_constraint):
                    return Issue(
                        kind=IssueKind.NULL_DEREFERENCE,
                        message=f"'{attr_name}' access on {obj.name} which could be None",
                        constraints=none_constraint,
                        model=get_model(none_constraint),
                        pc=state.pc,
                    )
        return None


class EnhancedTypeErrorDetector(Detector):
    """Enhanced type confusion detector.
    Includes pattern recognition to avoid false positives on dict access.
    """

    name = "enhanced-type-error"
    description = "Enhanced type confusion detection"
    issue_kind = IssueKind.TYPE_ERROR
    DICT_CONTAINER_PATTERNS = {
        "dict",
        "map",
        "cache",
        "tracker",
        "store",
        "registry",
        "config",
        "settings",
        "_recent",
        "_usage",
        "_count",
        "_limits",
        "_LIMITS",
        "_SIZE",
        "_join",
        "_command",
        "_confusion",
        "_requests",
        "global_",
    }
    SKIP_PREFIXES = ("subscr_", "call_result_", "call_kw_result_", "iter_")
    INSTANCE_ATTR_PATTERNS = (
        "self.",
        "cls.",
        ".stack",
        ".elements",
        ".items",
        ".values",
        ".keys",
        ".methods",
        ".fields",
        ".attributes",
        ".properties",
        "._hooks",
        "._pending",
        "._alias",
        "._references",
        ".locals",
        ".globals",
        ".block_stack",
        ".path_constraints",
        "frame_copy",
        "closure_parent",
    )

    def check(
        self,
        state: VMState,
        instruction: dis.Instruction,
        solver_check: callable,
    ) -> Issue | None:
        try:
            has_extended_types = True
        except ImportError:
            has_extended_types = False
        if instruction.opname == "BINARY_SUBSCR":
            return self._check_subscript_type(state, instruction)
        if not has_extended_types:
            return None
        if instruction.opname == "BINARY_OP":
            return self._check_binary_op(state, instruction)
        return None

    def _check_subscript_type(self, state, instruction):
        from pyspectre.core.solver import get_model, is_satisfiable
        from pyspectre.core.types import SymbolicValue

        if len(state.stack) < 2:
            return None
        container = state.stack[-2]
        if isinstance(container, SymbolicValue):
            container_name = getattr(container, "name", "") or ""
            if any(pattern in container_name.lower() for pattern in self.DICT_CONTAINER_PATTERNS):
                return None
            if container_name.startswith("global_"):
                return None
            if any(container_name.startswith(prefix) for prefix in self.SKIP_PREFIXES):
                return None
            if any(pattern in container_name for pattern in self.INSTANCE_ATTR_PATTERNS):
                return None
            subscript_int = [
                *state.path_constraints,
                container.is_int,
            ]
            if is_satisfiable(subscript_int):
                return Issue(
                    kind=IssueKind.TYPE_ERROR,
                    message=f"Attempting to subscript {container.name} which could be an int",
                    constraints=subscript_int,
                    model=get_model(subscript_int),
                    pc=state.pc,
                )
        return None

    def _check_binary_op(self, state, instruction):
        from pyspectre.core.solver import get_model, is_satisfiable
        from pyspectre.core.types import SymbolicString, SymbolicValue

        if len(state.stack) < 2:
            return None
        op = instruction.argrepr
        left = state.stack[-2]
        right = state.stack[-1]
        if op == "+":
            if isinstance(left, SymbolicString) and isinstance(right, SymbolicValue):
                type_error = [*state.path_constraints, right.is_int]
                if is_satisfiable(type_error):
                    return Issue(
                        kind=IssueKind.TYPE_ERROR,
                        message="Cannot concatenate string with int",
                        constraints=type_error,
                        model=get_model(type_error),
                        pc=state.pc,
                    )
        return None


class FormatStringDetector(Detector):
    """Detects potential format string vulnerabilities."""

    name = "format-string"
    description = "Detects format string injection vulnerabilities"
    issue_kind = IssueKind.FORMAT_STRING_INJECTION
    DANGEROUS_CALLS = {"eval", "exec", "compile", "getattr", "setattr"}

    def check(
        self,
        state: VMState,
        instruction: dis.Instruction,
        solver_check: callable,
    ) -> Issue | None:
        if instruction.opname in ("CALL", "CALL_FUNCTION"):
            return self._check_dangerous_call(state, instruction)
        if instruction.opname == "FORMAT_VALUE":
            return self._check_format_value(state, instruction)
        return None

    def _check_dangerous_call(self, state, instruction):
        try:
            from pyspectre.core.types import SymbolicString

            has_string = True
        except ImportError:
            has_string = False
        if not has_string:
            return None
        argc = int(instruction.argval) if instruction.argval else 0
        if argc > 0 and len(state.stack) >= argc:
            for i in range(argc):
                arg = state.stack[-(i + 1)]
                if isinstance(arg, SymbolicString):
                    if hasattr(arg, "taint_labels") and arg.taint_labels:
                        return Issue(
                            kind=IssueKind.FORMAT_STRING_INJECTION,
                            message="Potentially tainted string passed to function call",
                            constraints=list(state.path_constraints),
                            pc=state.pc,
                        )
        return None

    def _check_format_value(self, state, instruction):
        from pyspectre.core.types import SymbolicValue

        if len(state.stack) < 1:
            return None
        val = state.stack[-1]
        if isinstance(val, SymbolicValue):
            if hasattr(val, "taint_labels") and val.taint_labels:
                return Issue(
                    kind=IssueKind.FORMAT_STRING_INJECTION,
                    message="Tainted value used in format string",
                    constraints=list(state.path_constraints),
                    pc=state.pc,
                )
        return None


class ResourceLeakDetector(Detector):
    """Detects potential resource leaks (unclosed files, connections)."""

    name = "resource-leak"
    description = "Detects unclosed resources (files, connections)"
    issue_kind = IssueKind.RESOURCE_LEAK

    def check(
        self,
        state: VMState,
        instruction: dis.Instruction,
        solver_check: callable,
    ) -> Issue | None:
        if not hasattr(state, "_open_resources"):
            state._open_resources = set()
        if instruction.opname in ("LOAD_GLOBAL", "LOAD_NAME"):
            if instruction.argval == "open":
                state._pending_open = True
        if instruction.opname == "RETURN_VALUE":
            if hasattr(state, "_open_resources") and state._open_resources:
                return Issue(
                    kind=IssueKind.RESOURCE_LEAK,
                    message=f"Potential resource leak: {len(state._open_resources)} resource(s) may not be closed",
                    constraints=list(state.path_constraints),
                    pc=state.pc,
                )
        return None


class DetectorRegistry:
    """Registry of available detectors."""

    def __init__(self):
        self._detectors: dict[str, type[Detector]] = {}
        self._instances: dict[str, Detector] = {}
        self.register(DivisionByZeroDetector)
        self.register(AssertionErrorDetector)
        self.register(IndexErrorDetector)
        self.register(KeyErrorDetector)
        self.register(TypeErrorDetector)
        self.register(AttributeErrorDetector)
        self.register(OverflowDetector)
        self.register(EnhancedIndexErrorDetector)
        self.register(NoneDereferenceDetector)
        self.register(EnhancedTypeErrorDetector)
        self.register(FormatStringDetector)
        self.register(ResourceLeakDetector)

    def register(self, detector_class: type[Detector]) -> None:
        """Register a detector class."""
        self._detectors[detector_class.name] = detector_class

    def get(self, name: str) -> Detector | None:
        """Get a detector instance by name."""
        if name not in self._detectors:
            return None
        if name not in self._instances:
            self._instances[name] = self._detectors[name]()
        return self._instances[name]

    def get_all(self) -> list[Detector]:
        """Get all detector instances."""
        return [self.get(name) for name in self._detectors]

    def get_by_kind(self, kind: IssueKind) -> list[Detector]:
        """Get detectors for a specific issue kind."""
        return [self.get(name) for name, cls in self._detectors.items() if cls.issue_kind == kind]

    def list_available(self) -> list[str]:
        """List available detector names."""
        return list(self._detectors.keys())


default_registry = DetectorRegistry()

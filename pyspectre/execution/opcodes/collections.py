"""Collection opcodes (lists, tuples, dicts, sets)."""

from __future__ import annotations

import dis
from typing import TYPE_CHECKING

import z3

from pyspectre.analysis.detectors import Issue, IssueKind
from pyspectre.core.solver import get_model, is_satisfiable
from pyspectre.core.types import SymbolicDict, SymbolicList, SymbolicString, SymbolicValue
from pyspectre.execution.dispatcher import OpcodeResult, opcode_handler

if TYPE_CHECKING:
    from pyspectre.core.state import VMState
    from pyspectre.execution.dispatcher import OpcodeDispatcher


@opcode_handler("BUILD_LIST")
def handle_build_list(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Build a list from stack items."""
    count = int(instr.argval) if instr.argval else 0
    items = []
    for _ in range(count):
        if state.stack:
            items.insert(0, state.pop())
    sym_list, constraint = SymbolicList.symbolic(f"list_{state.pc}")
    sym_list.z3_len = z3.IntVal(count)
    state.push(sym_list)
    state.add_constraint(constraint)
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("BUILD_TUPLE")
def handle_build_tuple(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Build a tuple from stack items."""
    count = int(instr.argval) if instr.argval else 0
    items = []
    for _ in range(count):
        if state.stack:
            items.insert(0, state.pop())
    sym_list, constraint = SymbolicList.symbolic(f"tuple_{state.pc}")
    sym_list.z3_len = z3.IntVal(count)
    state.push(sym_list)
    state.add_constraint(constraint)
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("BUILD_SET")
def handle_build_set(instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher) -> OpcodeResult:
    """Build a set from stack items."""
    count = int(instr.argval) if instr.argval else 0
    for _ in range(count):
        if state.stack:
            state.pop()
    sym_val, constraint = SymbolicValue.symbolic(f"set_{state.pc}")
    state.push(sym_val)
    state.add_constraint(constraint)
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("BUILD_MAP")
def handle_build_map(instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher) -> OpcodeResult:
    """Build a dict from stack items."""
    count = int(instr.argval) if instr.argval else 0
    for _ in range(count * 2):
        if state.stack:
            state.pop()
    sym_dict, constraint = SymbolicDict.symbolic(f"dict_{state.pc}")
    state.push(sym_dict)
    state.add_constraint(constraint)
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("BUILD_CONST_KEY_MAP")
def handle_build_const_key_map(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Build a dict with constant keys."""
    count = int(instr.argval) if instr.argval else 0
    if state.stack:
        state.pop()
    for _ in range(count):
        if state.stack:
            state.pop()
    sym_dict, constraint = SymbolicDict.symbolic(f"dict_{state.pc}")
    state.push(sym_dict)
    state.add_constraint(constraint)
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("BUILD_STRING")
def handle_build_string(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Build a string from stack items (f-string)."""
    count = int(instr.argval) if instr.argval else 0
    for _ in range(count):
        if state.stack:
            state.pop()
    sym_str, constraint = SymbolicString.symbolic(f"fstring_{state.pc}")
    state.push(sym_str)
    state.add_constraint(constraint)
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("BUILD_SLICE")
def handle_build_slice(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Build a slice object."""
    argc = int(instr.argval) if instr.argval else 2
    for _ in range(argc):
        if state.stack:
            state.pop()
    sym_val, constraint = SymbolicValue.symbolic(f"slice_{state.pc}")
    state.push(sym_val)
    state.add_constraint(constraint)
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("LIST_EXTEND", "SET_UPDATE", "DICT_UPDATE", "DICT_MERGE")
def handle_collection_extend(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Extend a collection with another."""
    if state.stack:
        state.pop()
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("LIST_APPEND")
def handle_list_append(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Append to a list (used in list comprehensions)."""
    if state.stack:
        state.pop()
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("SET_ADD")
def handle_set_add(instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher) -> OpcodeResult:
    """Add to a set (used in set comprehensions)."""
    if state.stack:
        state.pop()
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("MAP_ADD")
def handle_map_add(instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher) -> OpcodeResult:
    """Add to a dict (used in dict comprehensions)."""
    if state.stack:
        state.pop()
    if state.stack:
        state.pop()
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("BINARY_SUBSCR")
def handle_binary_subscr(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Subscript operation (obj[key])."""
    index = state.pop()
    container = state.pop()
    issues = []
    if isinstance(container, SymbolicList) and isinstance(index, SymbolicValue):
        oob_check = [
            *state.path_constraints,
            index.is_int,
            z3.Or(
                index.z3_int < 0,
                index.z3_int >= container.z3_len,
            ),
        ]
        if is_satisfiable(oob_check):
            issues.append(
                Issue(
                    kind=IssueKind.INDEX_ERROR,
                    message=f"Possible index out of bounds: {container.name}[{index.name}]",
                    constraints=list(oob_check),
                    model=get_model(oob_check),
                    pc=state.pc,
                )
            )
        state.add_constraint(z3.And(index.z3_int >= 0, index.z3_int < container.z3_len))
        result = container[index]
    elif isinstance(container, SymbolicString) and isinstance(index, SymbolicValue):
        oob_check = [
            *state.path_constraints,
            index.is_int,
            z3.Or(
                index.z3_int < 0,
                index.z3_int >= container.z3_len,
            ),
        ]
        if is_satisfiable(oob_check):
            issues.append(
                Issue(
                    kind=IssueKind.INDEX_ERROR,
                    message=f"Possible string index out of bounds: {container.name}[{index.name}]",
                    constraints=list(oob_check),
                    model=get_model(oob_check),
                    pc=state.pc,
                )
            )
        state.add_constraint(z3.And(index.z3_int >= 0, index.z3_int < container.z3_len))
        result = container[index]
    elif isinstance(container, SymbolicDict) and isinstance(index, SymbolicString):
        result = container[index]
    else:
        result, constraint = SymbolicValue.symbolic(f"subscr_{state.pc}")
        state.add_constraint(constraint)
    state.push(result)
    state.pc += 1
    if issues:
        return OpcodeResult(new_states=[state], issues=issues)
    return OpcodeResult.continue_with(state)


@opcode_handler("STORE_SUBSCR")
def handle_store_subscr(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Store subscript (obj[key] = value)."""
    index = state.pop()
    container = state.pop()
    value = state.pop()
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("DELETE_SUBSCR")
def handle_delete_subscr(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Delete subscript (del obj[key])."""
    index = state.pop()
    container = state.pop()
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("BINARY_SLICE")
def handle_binary_slice(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Slice operation (obj[start:stop])."""
    stop = state.pop()
    start = state.pop()
    container = state.pop()
    if isinstance(container, SymbolicList):
        result_len = z3.Int(f"slice_len_{state.pc}")
        result, constraint = SymbolicList.symbolic(f"slice_{state.pc}")
        result.z3_len = result_len
        state.add_constraint(constraint)
        state.add_constraint(result_len >= 0)
        state.push(result)
    elif isinstance(container, SymbolicString):
        result, constraint = SymbolicString.symbolic(f"str_slice_{state.pc}")
        state.add_constraint(constraint)
        state.push(result)
    else:
        result, constraint = SymbolicValue.symbolic(f"slice_{state.pc}")
        state.add_constraint(constraint)
        state.push(result)
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("STORE_SLICE")
def handle_store_slice(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Store slice (obj[start:stop] = value)."""
    stop = state.pop()
    start = state.pop()
    container = state.pop()
    value = state.pop()
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("UNPACK_SEQUENCE")
def handle_unpack_sequence(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Unpack a sequence into individual values."""
    count = int(instr.argval) if instr.argval else 0
    if state.stack:
        state.pop()
    for i in range(count):
        val, constraint = SymbolicValue.symbolic(f"unpack_{state.pc}_{i}")
        state.push(val)
        state.add_constraint(constraint)
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("UNPACK_EX")
def handle_unpack_ex(instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher) -> OpcodeResult:
    """Unpack with starred target."""
    if state.stack:
        state.pop()
    arg = int(instr.argval) if instr.argval else 0
    before = arg & 0xFF
    after = (arg >> 8) & 0xFF
    for i in range(before + 1 + after):
        val, constraint = SymbolicValue.symbolic(f"unpack_ex_{state.pc}_{i}")
        state.push(val)
        state.add_constraint(constraint)
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("FORMAT_VALUE")
def handle_format_value(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Format a value for f-strings."""
    flags = int(instr.argval) if instr.argval else 0
    if flags & 0x04:
        if state.stack:
            state.pop()
    if state.stack:
        state.pop()
    sym_str, constraint = SymbolicString.symbolic(f"formatted_{state.pc}")
    state.push(sym_str)
    state.add_constraint(constraint)
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("CONVERT_VALUE")
def handle_convert_value(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Convert value for f-string (Python 3.13+)."""
    if state.stack:
        state.pop()
    sym_str, constraint = SymbolicString.symbolic(f"converted_{state.pc}")
    state.push(sym_str)
    state.add_constraint(constraint)
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("FORMAT_SIMPLE")
def handle_format_simple(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Simple format (Python 3.13+)."""
    if state.stack:
        state.pop()
    sym_str, constraint = SymbolicString.symbolic(f"format_simple_{state.pc}")
    state.push(sym_str)
    state.add_constraint(constraint)
    state.pc += 1
    return OpcodeResult.continue_with(state)


@opcode_handler("FORMAT_WITH_SPEC")
def handle_format_with_spec(
    instr: dis.Instruction, state: VMState, ctx: OpcodeDispatcher
) -> OpcodeResult:
    """Format with spec (Python 3.13+)."""
    if state.stack:
        state.pop()
    if state.stack:
        state.pop()
    sym_str, constraint = SymbolicString.symbolic(f"format_spec_{state.pc}")
    state.push(sym_str)
    state.add_constraint(constraint)
    state.pc += 1
    return OpcodeResult.continue_with(state)
